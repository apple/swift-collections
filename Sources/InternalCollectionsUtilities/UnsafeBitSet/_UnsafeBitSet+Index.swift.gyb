//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Collections open source project
//
// Copyright (c) 2021 - 2024 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

%{
  from gyb_utils import *
}%
${autogenerated_warning()}

% for modifier in visibility_levels:
${visibility_boilerplate(modifier)}
extension _UnsafeBitSet {
  ${"@frozen" if modifier == "public" else "@frozen @usableFromInline"}
  ${modifier} struct Index: Comparable, Hashable {
    @usableFromInline
    internal typealias _Word = _UnsafeBitSet._Word

    ${"@usableFromInline" if modifier != "public" else ""}
    ${modifier} var value: UInt

    @inlinable
    ${modifier} init(_ value: UInt) {
      self.value = value
    }

    @inlinable
    ${modifier} init(_ value: Int) {
      self.value = UInt(value)
    }

    @inlinable
    ${modifier} init(word: Int, bit: UInt) {
      assert(word >= 0 && word <= Int.max / _Word.capacity)
      assert(bit < _Word.capacity)
      self.value = UInt(word &* _Word.capacity) &+ bit
    }
  }
}

extension _UnsafeBitSet.Index {
  @inlinable
  ${modifier} var word: Int {
    // Note: We perform on UInts to get faster unsigned math (shifts).
    Int(truncatingIfNeeded: value / UInt(bitPattern: _Word.capacity))
  }

  @inlinable
  ${modifier} var bit: UInt {
    // Note: We perform on UInts to get faster unsigned math (masking).
    value % UInt(bitPattern: _Word.capacity)
  }

  @inlinable
  ${modifier} var split: (word: Int, bit: UInt) {
    (word, bit)
  }

  @inlinable
  ${modifier} var endSplit: (word: Int, bit: UInt) {
    let w = word
    let b = bit
    if w > 0, b == 0 { return (w &- 1, UInt(_Word.capacity)) }
    return (w, b)
  }

  @inlinable
  ${modifier} static func ==(left: Self, right: Self) -> Bool {
    left.value == right.value
  }

  @inlinable
  ${modifier} static func <(left: Self, right: Self) -> Bool {
    left.value < right.value
  }

  @inlinable
  ${modifier} func hash(into hasher: inout Hasher) {
    hasher.combine(value)
  }

  @inlinable
  internal func _successor() -> Self {
    Self(value + 1)
  }

  @inlinable
  internal func _predecessor() -> Self {
    Self(value - 1)
  }
}
% end
${visibility_boilerplate("end")}
